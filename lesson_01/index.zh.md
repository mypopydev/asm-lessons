**FFmpeg 汇编语言第一课**

**简介**

欢迎来到 FFmpeg 汇编语言学院。你已经迈出了编程中最有趣、最具挑战性、最值得的一段旅程的第一步。这些课程将为你打下 FFmpeg 中汇编语言编写的基础，并让你大开眼界，了解计算机内部的实际运作方式。

**必备知识**

* C 语言知识，特别是指针。如果你不了解 C，请通读 [C程序设计语言](https://en.wikipedia.org/wiki/The_C_Programming_Language) 这本书
* 高中数学（标量与向量，加法，乘法等）

**什么是汇编语言？**

汇编语言是一种编程语言，你编写的代码直接对应于 CPU 处理的指令。顾名思义，人类可读的汇编语言被*汇编*（assembled）成二进制数据，称为*机器码*（machine code），即 CPU 可以理解的代码。你可能会看到汇编语言代码被简称为 “assembly” 或 “asm”。

FFmpeg 中的绝大多数汇编代码都是所谓的 *SIMD（Single Instruction Multiple Data，即单指令多数据）*。SIMD 有时被称为向量编程。这意味着一条特定指令同时对多个数据元素进行操作。大多数编程语言一次操作一个数据元素，称为标量编程（scalar programming）。

你可能已经猜到了，SIMD 非常适合处理图像、视频和音频，因为这些数据在内存中按顺序大量排列。CPU 中提供了专门的指令来帮助我们处理顺序数据。

在 FFmpeg 中，你会看到术语 “assembly function”（汇编函数）、“SIMD” 和 “vector(ise)”（向量化）互换使用。它们都指代同一件事：手工编写汇编语言函数，一次性处理多个数据元素。有些项目也可能将其称为 “assembly kernels”（汇编内核）。

所有这些听起来可能很复杂，但要记住，在 FFmpeg 中，甚至有高中生编写过汇编代码。和其他事情一样，学习过程是 50% 的行话和 50% 的实际学习。

**为什么要用汇编语言编写？**
为了让多媒体处理变得飞快。编写汇编代码通常能获得 10 倍或更高的速度提升，这对于想要流畅实时播放视频尤为重要。它还能节省能源并延长电池寿命。值得指出的是，视频编码和解码函数是地球上使用最频繁的函数之一，无论是终端用户还是大公司的数据中心都在使用。因此，即使是很小的改进也会迅速累积。

你在网上经常会看到人们使用 *intrinsics（内置函数）*，这是一种类似 C 的函数，映射到汇编指令以允许更快的开发。在 FFmpeg 中，我们不使用 intrinsics，而是手工编写汇编代码。这是一个有争议的领域，但 intrinsics 通常比手写汇编慢 10-15% 左右（intrinsics 支持者可能会不同意），具体取决于编译器。对于 FFmpeg 来说，每一分额外的性能都有帮助，这就是为什么我们直接用汇编代码编写。还有一个论点是，intrinsics 由于使用了 “[匈牙利命名法](https://en.wikipedia.org/wiki/Hungarian_notation)” 而难以阅读。

你也可能在 FFmpeg 的少数地方看到由于历史原因保留的 *inline assembly（内联汇编）*（即不使用 intrinsics），或者在像 Linux 内核这样的项目中因为非常特定的用例而看到它。这是指汇编代码不在单独的文件中，而是内联写在 C 代码中。在像 FFmpeg 这样的项目中，普遍的观点是这种代码难以阅读，编译器支持不广泛，且难以维护。

最后，你会看到网上有很多自封的专家说这些都没必要，编译器可以为你做所有的 “向量化”。至少为了学习的目的，忽略他们：最近在例如 [dav1d 项目](https://www.videolan.org/projects/dav1d.html) 中的测试显示，这种自动向量化大约能带来 2 倍的加速，而手写版本可以达到 8 倍。

**汇编语言的种类**
这些课程将专注于 x86 64 位汇编语言。这也称为 amd64，尽管它仍然适用于 Intel CPU。还有针对其他 CPU（如 ARM 和 RISC-V）的其他类型的汇编，未来这些课程可能会扩展到涵盖那些内容。

你在网上会看到两种 x86 汇编语法风格：AT&T 和 Intel。与 Intel 语法相比，AT&T 语法较老且难以阅读。所以我们将使用 Intel 语法。

**辅助材料**
听到书籍或像 Stack Overflow 这样的在线资源作为参考并不是特别有帮助，你可能会感到惊讶。部分原因是我们选择使用 Intel 语法的手写汇编。但也因为很多在线资源专注于操作系统编程或硬件编程，通常使用非 SIMD 代码。FFmpeg 汇编特别专注于高性能图像处理，正如你将看到的，这是一种特别独特的汇编编程方法。也就是说，一旦你完成了这些课程，就很容易理解其他汇编用例。

许多书在教汇编之前会深入讲解大量计算机架构细节。如果你想学的就是那个，那没问题，但从我们的立场来看，这就像在学开车之前研究引擎一样。

话虽如此，“The Art of 64-bit assembly” 一书后半部分展示 SIMD 指令及其行为的图表非常有帮助：[https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/)

有一个 discord 服务器可供提问：
[https://discord.com/invite/Ks5MhUhqfB](https://discord.com/invite/Ks5MhUhqfB)

**寄存器**
寄存器是 CPU 中可以处理数据的区域。CPU 不直接操作内存，而是将数据加载到寄存器中，进行处理，然后写回内存。在汇编语言中，通常情况下，你不能不通过寄存器直接将数据从一个内存位置复制到另一个位置。

**通用寄存器**
第一种类型的寄存器被称为通用寄存器（General Purpose Register，GPR）。GPR 被称为通用是因为它们既可以包含数据（在这里最高为 64 位值），也可以包含内存地址（指针）。GPR 中的值可以通过加法、乘法、移位等操作进行处理。

在大多数汇编书中，有整章专门介绍 GPR 的细微差别、历史背景等。这是因为 GPR 在涉及操作系统编程、逆向工程等时非常重要。在 FFmpeg 编写的汇编代码中，GPR 更像是脚手架，大多数时候它们的复杂性是不需要的，并且被抽象掉了。

**向量寄存器**
向量 (SIMD) 寄存器，顾名思义，包含多个数据元素。有各种类型的向量寄存器：

* mm 寄存器 - MMX 寄存器，64 位大小，具有历史意义且不再多用
* xmm 寄存器 - XMM 寄存器，128 位大小，广泛可用
* ymm 寄存器 - YMM 寄存器，256 位大小，使用时有一些复杂性
* zmm 寄存器 - ZMM 寄存器，512 位大小，可用性有限

视频压缩和解压缩中的大多数计算都是基于整数的，所以我们将坚持使用整数。这是一个 xmm 寄存器中 16 个字节的示例：

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

但它也可以是 8 个字（16 位整数）

| a | b | c | d | e | f | g | h |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

或者 4 个双字（32 位整数）

| a | b | c | d |
| :---- | :---- | :---- | :---- |

或者 2 个四字（64 位整数）：

| a | b |
| :---- | :---- |

回顾一下：

* **b**ytes - 8 位数据 (字节)
* **w**ords - 16 位数据 (字)
* **d**oublewords - 32 位数据 (双字)
* **q**uadwords - 64 位数据 (四字)
* **d**ouble **q**uadwords - 128 位数据 (双四字)

粗体字符稍后会很重要。

**x86inc.asm include**
你会看到在许多例子中我们包含了 x86inc.asm 文件。X86inc.asm 是在 x264、FFmpeg 和 dav1d 中使用的一个轻量级抽象层，旨在让汇编程序员的生活更轻松。它在很多方面都有帮助，但首先，它做的一件有用的事情是标记 GPR，r0, r1, r2。这意味着你不必记住任何寄存器名称。如前所述，GPR 通常只是脚手架，所以这让生活轻松了很多。

**一个简单的标量 asm 片段**

让我们看一个简单的（也是非常人工的）标量 asm 片段（在每条指令中一次操作一个单独数据项的汇编代码），看看发生了什么：

```assembly
mov  r0q, 3  
inc  r0q  
dec  r0q  
imul r0q, 5
```

在第一行中，*立即数*（immediate value）3（直接存储在汇编代码本身中的值，而不是从内存中获取的值）被作为四字存储到寄存器 r0 中。注意在 Intel 语法中，源操作数（source operand，提供数据的值或位置，位于右侧）被传输到目标操作数（destination operand，接收数据的位置，位于左侧），就像 memcpy 的行为一样。既然顺序相同，你也可以将其读作 “r0q = 3”。r0 的 “q” 后缀将寄存器指定为用作四字。inc 增加该值，使 r0q 包含 4，dec 将该值减回 3。imul 将该值乘以 5。所以最后，r0q 包含 15。

注意，像 mov 和 inc 这样的人类可读指令，被汇编器汇编成机器码，被称为 *mnemonics（助记符）*。你可能会在网上和书中看到用大写字母表示的助记符，如 MOV 和 INC，但这些与小写版本相同。在 FFmpeg 中，我们使用小写助记符，并保留大写用于宏。

**理解一个基本的向量函数**

这是我们的第一个 SIMD 函数：

```assembly
%include "x86inc.asm"

SECTION .text

;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2  
cglobal add_values, 2, 2, 2, src, src2   
    movu  m0, [srcq]  
    movu  m1, [src2q]

    paddb m0, m1

    movu  [srcq], m0

    RET
```

让我们逐行分析：

```assembly
%include "x86inc.asm"
```

这是 x264、FFmpeg 和 dav1d 社区开发的 “头文件”，提供辅助程序、预定义名称和宏（如下面的 cglobal）以简化编写汇编。

```assembly
SECTION .text
```

这表示你要执行的代码所在的段。这与 .data 段相反，你可以在那里放置常量数据。

```assembly
;static void add_values(uint8_t *src, const uint8_t *src2)  
INIT_XMM sse2
```

第一行是一个注释（asm 中的分号 “;” 就像 C 中的 “//”）展示了 C 中的函数参数是什么样的。第二行展示了我们如何初始化函数以使用 XMM 寄存器，使用 sse2 指令集。这是因为 paddb 是一个 sse2 指令。我们将在下一课中更详细地介绍 sse2。

```assembly
cglobal add_values, 2, 2, 2, src, src2
```

这是一行重要的代码，因为它定义了一个名为 “add_values” 的 C 函数。

让我们逐项分析：

* 下一个参数显示它有两个函数参数。
* 再下一个参数显示我们将在这个函数中使用两个 GPR，包括参数。在某些情况下，我们可能想要使用更多的 GPR，所以我们必须告诉 x86util 我们需要更多。
* 再下一个参数告诉 x86util 我们将使用多少个 XMM 寄存器。
* 接下来的两个参数是函数参数的标签。

值得注意的是，较旧的代码可能没有函数参数的标签，而是直接使用 r0, r1 等寻址 GPR。

```assembly
    movu  m0, [srcq]  
    movu  m1, [src2q]
```

movu 是 movdqu（move double quad unaligned，即移动双四字未对齐）的简写。对齐将在另一课中介绍，但现在 movu 可以被视为从 [srcq] 进行的 128 位移动。在 mov 的情况下，括号意味着 [srcq] 中的地址正在被解引用，相当于 *C 中的 \*src。* 这就是所谓的加载 (load)。注意 “q” 后缀指的是指针的大小 *(*即在 C 中它代表 *sizeof(\*src) == 8* 在 64 位系统上，x86asm 足够聪明，在 32 位系统上使用 32 位)，但底层的加载是 128 位的。

注意我们不通过全名引用向量寄存器，在这种情况下是 xmm0，而是作为 m0，一种抽象形式。在未来的课程中，你将看到这意味着你可以编写一次代码，让它在多种 SIMD 寄存器大小上工作。

```assembly
paddb m0, m1
```

paddb（在脑海中读作 *p-add-b*）正在将每个寄存器中的每个字节相加，如下所示。“p” 前缀代表 “packed”（打包），用于识别向量指令与标量指令。“b” 后缀表示这是逐字节加法（字节的加法）。

| a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\+

| q | r | s | t | u | v | w | x | y | z | aa | ab | ac | ad | ae | af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

\=

| a+q | b+r | c+s | d+t | e+u | f+v | g+w | h+x | i+y | j+z | k+aa | l+ab | m+ac | n+ad | o+ae | p+af |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |

```assembly
movu  [srcq], m0
```

这就是所谓的存储 (store)。数据被写回 srcq 指针中的地址。

```assembly
RET
```

这是一个表示函数返回的宏。实际上 FFmpeg 中的所有汇编函数都会修改参数中的数据，而不是返回值。

正如你在作业中会看到的，我们创建指向汇编函数的函数指针，并在可用的地方使用它们。

[下一课](../lesson_02/index.zh.md)
